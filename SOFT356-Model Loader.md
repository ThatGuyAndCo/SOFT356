# __SOFT356- Procedurally Generated Level__
# Jake Morgan


#IMPORTANT
To use the solution, please install the following NuGet packages into the solution:
- glm by GLM contributors (v0.9.9.600)
- nupengl.core by Jonathan Dickinson (v0.1.0.1, later versions should work too)
- pugixml by Arseny Kapoulkine (v1.10.0)

The folder containing the executable is called 'Assignment 2 Executables'. This also contains necessary model and shader files for the program.

Youtube commentary: https://youtu.be/XOyxIVW7LkI
Sorry for the length, the first 6 mins is talking through the basic algorithm as it is running, the final 7 minutes is me showing it without the console outs (much more efficient) and modifying generation chances to change the shape of the generated structure, before covering what I think are the strengths and flaws. The middle section of the video is me talking through the code and what everything does.

# Disclaimer:
3rd Party Dependencies:
- FreeGLUT
- GLEW
- GLM
- stb_image
- pugi XML Reader

Code has been written from scratch unless otherwise stated, using mainly the tutorials provided at https://www.opengl-tutorial.org/, a variety of Stack Overflow posts, the code available on the SOFT356 Github repo under the ‘Sample Code’ folder.
The code obtained from these sources has been reworked to fit my own need and is in no way a direct copy. Some similarities may occur in areas without much ‘wiggle room’ for customising the code (such as the shaders).
2 direct exceptions to this are __LoadShaders.cpp__ which is directly copied from the SOFT356 repo, and the __getFileName()__ method in the __ModelLoader.cpp__, which has been copied from https://www.daniweb.com/programming/software-development/threads/159753/opening-a-filedialog as this is a fairly standard c++ function. This has been credited in the code.
This project re-uses my Model Loader code from Assignment 1 as a basis. There are some new methods in the Model class that contain variations on the original work to make things slightly more user-friendly (e.g. pointing to static resources rather than allowing the user to pick models/textures). Any additions to the ModelLoader.cpp will be covered later.

# Which version of Visual Studio, OpenGL?
This has been built in VisualStudio 2019 using OpenGL 4.1.

# How does the user interact with the executable?
The 'Assignment 2 Executable' folder contains all necessary stuff for the program to run. Please ensure the 'Test Files' and 'Shader' folders are there before trying to run the executable.
Upon launching the application, a console window will appear. The window will give an option to print a tutorial, which will list some helpful information and console commands. After proceeding, a view window will open and you will be required to tab back to the console. You will see a prompt asking for a number of rooms to generate. Input a number between 2 and 999 (for efficiency purposes). Tab back to the GL window, and the mouse will be captured to this window as it is used to rotate the camera, and the wasd/qe keys are used to move the camera around the scene. Pressing the ESCAPE button will open a menu in the console (and uncapture the mouse). The menu will list commands the application is capable of (such as create a new scene using a different number of rooms, or quickly generate a new scene using the same number of rooms) as well as various commands for changing the movement speed / sensitivity for comfort when navigating the scenes.
When the scene loads, the camera will auto center to the 'starting cell': the cell at the center of the generated scene. The scene can then be navigated using the camera controls (mouse and wasd/qe). There is a 'goal' room which contains a pedestal-like structure. centering the camera on this room and pressing the 'F' button to interact will generate a new level structure with the same number of rooms as the existing one, replacing the existing one, and the camera will be recentered to the new level.

# How does your program code work? / How do the classes fit together and who does what?
There are 3 new classes for the procedural generation code, and these are split into their own header and cpp files. The first one: **ProcGen** contains basic code to initialize the process. This class saves the most recent number of rooms to allow the code to be rerun without prompting another input. The code runs some basic regex input validation and passes the torch to the next class.
**ProcGenStructure** has one main method. This is where the procedural generation takes place. The method is very simple and easy to understand, but bulky. First, we initialise the nested vectors (referred to as map). This means, although highly unlikely as the odds are uniform, the level can take on a squished structure, appearing far wider along the x axis than the z, or vice versa. The cell at the center of the map is used as the initial starting cell. This will be the cell the player spawns at and the cell all others will branch from. After initialising a randomiser (as the normal rand() function must be manually seeded) we start generating the map properly. This is done in a while loop, to ensure we keep generating until the proper number of rooms is reached. It loops through the entire map, and for every currently open cell, it will have a base 60% chance to activate each adjacent cell. For each cell adjacent to the cell that ill be created, this chance goes down, becoming incredibly unlikely if cells are on each side. I messed around with a lot of configurations and stuck with a 20x multiplier to the randomly generated number for each adjacent room. This means that generations can take a bit longer, but the shapes and levels generated are much more interesting as a result, and do not clump together like they do at less extreme scales.
After the correct number of rooms is generated, the program will loop over the map one more time, this time to link up all connected rooms. This process is very quick, as for each active cell in the map, it only makes a total of up to 9 method calls to fully link up each cell: one to check each adjacent cell is being used, one to set the room's door array if the adjacent cell is being used, and finally one to calculate which model needs to be used and how it needs to be rotated. It then adds this to a single vector of 'enabled' rooms, and fully deletes the map row by row (to ensure memory is properly cleared). For a maximum size map of 999 rooms, with the chosen level of forced 'spread' between cells, this algorith takes aprox. 1 min to run. For a standard 50 cell sized level, at the same complexity, it takes aprox. 3.5 seconds. This speed would be severely decreased if more complex models were used, however given that this project was not about efficient model loading, I did not program it to reuse individual models, and it will load each model's file again each time it is required. By adding a copy model function (or using a 3rd party model loading library), the speed of the post-algorithm loding would be much faster with complex models.
Finally, the third class is the **ProcGenRoom** class. I chose a class over a struct as there was a lot of data to hold and there were some claculations specific to that dta that would be neater when stored together. This class holds the map coordinates, room type, number and position of doors, the model name and the rotation the model will need to match up with the doors. Most of this data is just for reference when either translating the model matricies in the **ModelLoader** or checking various things such as the start and goal locations in the **ModelLoader**'s pipeline. The door positions array is a set of 4 booleans indicating wether there is a door needed at the north, east, south and west positions of the cell. When a room is enabled, there is a random number passed in, which is used to generate the goal room. Each room has a 5% chance of being the goal, except the final room which will always be the goal if one has not already been made. If the room is the goal room, it will have it's room type set to '1' to indicate it needs a different model variation. During the 'linking' phase, the room uses a few methods to determine which model type is needed. It does this by looking at the number of trues in the boolean array, and uses their position to determine which base model to use (if necessary). It then rotates each model up to 4 times (2 or 0 times for certain models) until the position of the doors in the array lines up with what the doors should be on the model. Each model has been made to initially face the same direction, which helps reduce the complexity of this rotation section.
There are a few changes in the pipeline of the **ModelLoader** file that allows the procedurally generated data to be displayed and interacted with. The biggest changes are additions of functions to initialise the proc gen and to sort the data once it is retrieved. It uses the model name string constructed in the **ProcGenRoom** to load the correct model and then uses the map coords to translate it into the correct position.  It rotates the model to where is needed, and keeps track of the goal model.
Another major change was a second set of shaders. These were designed to be run specifically on the goal cell, and whilst in use no other cell will be rendered. This is used to check the colour of the center-screen pixel between frames to determine if the user is looking at the goal state. Combined with a key callback to the 'F' key, this will allow the user to interact with the goal cell and load a new level of the same size as before. The size can be changed by loaded a new level via the main menu (escape key).

# What makes your program special and how does it compare to similar things?
What makes my code stand out is the sheer simplicity of it. It has been designed for levels of a specific type and size, and performs somewhat efficiently for the given sizes. Whilst I originally said I would look at a pathfinding algorithm to grow the cells, I felt an algorithm similar to a QLeraning one would be much more approriate. This way, it could be easily expanded to include some AI-like behaviour in the generation if desired. It is also very simple to read and understand the workings of. It uses no complicated maths or library functions which makes it very easy to integrate into other programs with very few changes needed, and is easily customisable too. Whilst it is less efficient than other professional variants of a procedural generation algorithm, it still performs very well for everything but massive maps.

# Anything else which will help us to understand how your prototype works?
Physically: All information required to operate the program can be found in the tutorial or menu. The window may initially appear over the console, and appear blank, after the tutorial. Tabbing over to the console will show you what to do next. The selection is not automatically shifted to the console when the menu is opened, you will need to click in the console to type commands.  I deliberately left in cout's during the algorithm's running. This will have a large impact on performance (the times mentioned above are with cout's enabled) but I feel it is useful to showcase the process the algorithm takes in real time.
Programmatically: I have tried to split everything into classes following OOP principles, and focusing on extendability. Variable names and method names should be self explanatory. I have deliberately seperated as much functionality as possible so that the only data the algorithm handles is constructing the file name and generic data that could apply to any implementation of this map generation algorithm.

